"""
Regression tests comparing current results against stored reference data.

These tests load pre-computed reference data from .npz files and verify that
the current code produces identical (or very close) results. This catches
numerical regressions that might not be detected by validity checks alone.

Reference data is generated by: scripts/generate_reference_data.py
"""

import pytest
import numpy as np
from pathlib import Path

from revelsMD.revels_rdf import RevelsRDF
from revelsMD.density import DensityGrid
from .conftest import assert_arrays_close

REFERENCE_DIR = Path(__file__).parent.parent / "reference_data"


def load_reference(subdir: str, filename: str):
    """Load reference data, skip test if not available."""
    ref_path = REFERENCE_DIR / subdir / filename
    if not ref_path.exists():
        pytest.skip(f"Reference data not available: {ref_path}")
    return dict(np.load(ref_path, allow_pickle=True))


# ---------------------------------------------------------------------------
# LAMMPS Regression Tests
# ---------------------------------------------------------------------------

@pytest.mark.integration
@pytest.mark.regression
@pytest.mark.requires_example1
class TestLammpsRegression:
    """Regression tests against stored LAMMPS Example 1 results."""

    def test_rdf_forward_regression(self, example1_trajectory):
        """RDF forward integration matches stored reference and has valid physics."""
        ref = load_reference("lammps_example1", "rdf_forward.npz")

        result = RevelsRDF.run_rdf(
            example1_trajectory, '1', '1',
            delr=0.02, from_zero=True, start=0, stop=5
        )

        # Regression check against stored data
        assert_arrays_close(
            result[0], ref['r'],
            rtol=1e-10, context="r values"
        )
        assert_arrays_close(
            result[1], ref['g_r'],
            rtol=1e-10, context="g(r) forward"
        )

        # Physical property checks (saves computing RDF twice)
        # g(r) should have a first peak (LJ fluid)
        assert np.max(result[1]) > 1.0, "LJ fluid should have g(r) peak > 1"

        # Check first peak position (LJ sigma ~ 1.0 in reduced units)
        short_range_mask = result[0] < 2.0
        short_range_r = result[0][short_range_mask]
        short_range_gr = result[1][short_range_mask]
        if len(short_range_gr) > 0:
            peak_idx = np.argmax(short_range_gr)
            peak_r = short_range_r[peak_idx]
            assert 0.8 < peak_r < 1.5, f"First peak at r = {peak_r}, expected near 1.0"

        # Check normalisation in bulk region (r > 3 sigma)
        bulk_mask = result[0] > 3.0
        if np.any(bulk_mask):
            bulk_gr = result[1][bulk_mask]
            mean_bulk = np.mean(bulk_gr)
            assert abs(mean_bulk - 1.0) < 0.2, f"Bulk g(r) = {mean_bulk}, expected ~1.0"

    def test_rdf_backward_regression(self, example1_trajectory):
        """RDF backward integration matches stored reference."""
        ref = load_reference("lammps_example1", "rdf_backward.npz")

        result = RevelsRDF.run_rdf(
            example1_trajectory, '1', '1',
            delr=0.02, from_zero=False, start=0, stop=5
        )

        assert_arrays_close(
            result[0], ref['r'],
            rtol=1e-10, context="r values"
        )
        assert_arrays_close(
            result[1], ref['g_r'],
            rtol=1e-10, context="g(r) backward"
        )

    def test_rdf_lambda_regression(self, example1_trajectory):
        """RDF lambda combination matches stored reference."""
        ref = load_reference("lammps_example1", "rdf_lambda.npz")

        result = RevelsRDF.run_rdf_lambda(
            example1_trajectory, '1', '1',
            delr=0.02, start=0, stop=5
        )

        assert_arrays_close(
            result, ref['data'],
            rtol=1e-10, context="RDF lambda"
        )

    def test_number_density_regression(self, example1_trajectory):
        """3D number density matches stored reference."""
        ref = load_reference("lammps_example1", "number_density.npz")

        gs = DensityGrid(
            example1_trajectory, 'number', nbins=30
        )
        gs.make_force_grid(
            example1_trajectory, '1', kernel='triangular',
            rigid=False, start=0, stop=5
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="number density"
        )


# ---------------------------------------------------------------------------
# MDA/GROMACS Regression Tests
# ---------------------------------------------------------------------------

@pytest.mark.integration
@pytest.mark.regression
@pytest.mark.requires_example4
class TestMDARegression:
    """Regression tests against stored MDA Example 4 results."""

    def test_rdf_lambda_regression(self, example4_trajectory):
        """RDF lambda matches stored reference."""
        ref = load_reference("mda_example4", "rdf_lambda_ow.npz")

        result = RevelsRDF.run_rdf_lambda(
            example4_trajectory, 'Ow', 'Ow',
            delr=0.1, start=0, stop=5
        )

        assert_arrays_close(
            result, ref['data'],
            rtol=1e-10, context="RDF lambda Ow-Ow"
        )

    def test_number_density_regression(self, example4_trajectory):
        """3D number density matches stored reference."""
        ref = load_reference("mda_example4", "number_density_ow.npz")

        gs = DensityGrid(
            example4_trajectory, 'number', nbins=30
        )
        gs.make_force_grid(
            example4_trajectory, 'Ow', kernel='triangular',
            rigid=False, start=0, stop=5
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="number density Ow"
        )

    def test_rigid_density_regression(self, example4_trajectory):
        """Rigid molecule number density matches stored reference."""
        ref = load_reference("mda_example4", "number_density_rigid.npz")

        gs = DensityGrid(
            example4_trajectory, 'number', nbins=30
        )
        gs.make_force_grid(
            example4_trajectory, ['Ow', 'Hw1', 'Hw2'], kernel='triangular',
            rigid=True, start=0, stop=5
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="rigid number density"
        )

    def test_polarisation_density_regression(self, example4_trajectory):
        """Polarisation density matches stored reference."""
        ref = load_reference("mda_example4", "polarisation_density.npz")

        gs = DensityGrid(
            example4_trajectory, 'polarisation', nbins=30
        )
        gs.make_force_grid(
            example4_trajectory, ['Ow', 'Hw1', 'Hw2'], kernel='triangular',
            rigid=True, start=0, stop=5
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="polarisation density"
        )


# ---------------------------------------------------------------------------
# VASP Regression Tests
# ---------------------------------------------------------------------------

@pytest.mark.integration
@pytest.mark.regression
@pytest.mark.requires_vasp
class TestVASPRegression:
    """Regression tests against stored VASP results (BaSnF4)."""

    def test_rdf_lambda_regression(self, vasp_trajectory):
        """RDF lambda matches stored reference."""
        ref = load_reference("vasp_example3", "rdf_lambda_f_f.npz")

        result = RevelsRDF.run_rdf_lambda(
            vasp_trajectory, 'F', 'F',
            delr=0.1, start=0, stop=10
        )

        assert_arrays_close(
            result, ref['data'],
            rtol=1e-10, context="RDF lambda F-F"
        )

    def test_number_density_regression(self, vasp_trajectory):
        """3D number density matches stored reference."""
        ref = load_reference("vasp_example3", "number_density_f.npz")

        gs = DensityGrid(
            vasp_trajectory, 'number', nbins=30
        )
        gs.make_force_grid(
            vasp_trajectory, 'F', kernel='triangular',
            rigid=False, start=0, stop=10
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="number density F"
        )


# ---------------------------------------------------------------------------
# Synthetic Trajectory Regression Tests
# ---------------------------------------------------------------------------

@pytest.mark.integration
@pytest.mark.regression
@pytest.mark.analytical
class TestSyntheticRegression:
    """
    Regression tests against stored synthetic trajectory results.

    These tests use deterministic random seeds, so results should be
    bit-for-bit identical across runs.
    """

    def test_uniform_gas_rdf_regression(self, uniform_gas_trajectory):
        """Uniform gas RDF matches stored reference."""
        ref = load_reference("synthetic", "uniform_gas_rdf.npz")

        result = RevelsRDF.run_rdf_lambda(
            uniform_gas_trajectory, '1', '1',
            delr=0.1, start=0, stop=None
        )

        assert_arrays_close(
            result, ref['data'],
            rtol=1e-10, context="uniform gas RDF"
        )

    def test_uniform_gas_density_regression(self, uniform_gas_trajectory):
        """Uniform gas density matches stored reference."""
        ref = load_reference("synthetic", "uniform_gas_density.npz")

        gs = DensityGrid(
            uniform_gas_trajectory, 'number', nbins=30
        )
        gs.make_force_grid(
            uniform_gas_trajectory, '1', kernel='triangular', rigid=False
        )
        gs.get_real_density()

        assert_arrays_close(
            gs.rho, ref['rho'],
            rtol=1e-10, context="uniform gas density"
        )


# ---------------------------------------------------------------------------
# Meta-tests for reference data integrity
# ---------------------------------------------------------------------------

@pytest.mark.integration
@pytest.mark.regression
class TestReferenceDataIntegrity:
    """Tests that verify the reference data files are valid."""

    def test_lammps_references_exist(self):
        """LAMMPS reference files exist and are loadable."""
        ref_dir = REFERENCE_DIR / "lammps_example1"
        if not ref_dir.exists():
            pytest.skip("LAMMPS reference data not generated")

        expected_files = [
            "rdf_forward.npz",
            "rdf_backward.npz",
            "rdf_lambda.npz",
            "number_density.npz",
        ]

        for filename in expected_files:
            ref_path = ref_dir / filename
            assert ref_path.exists(), f"Missing reference: {ref_path}"
            data = np.load(ref_path)
            assert len(data.files) > 0, f"Empty reference: {ref_path}"

    def test_mda_references_exist(self):
        """MDA reference files exist and are loadable."""
        ref_dir = REFERENCE_DIR / "mda_example4"
        if not ref_dir.exists():
            pytest.skip("MDA reference data not generated")

        expected_files = [
            "rdf_lambda_ow.npz",
            "number_density_ow.npz",
            "number_density_rigid.npz",
            "polarisation_density.npz",
        ]

        for filename in expected_files:
            ref_path = ref_dir / filename
            assert ref_path.exists(), f"Missing reference: {ref_path}"
            data = np.load(ref_path)
            assert len(data.files) > 0, f"Empty reference: {ref_path}"

    def test_vasp_references_exist(self):
        """VASP reference files exist and are loadable."""
        ref_dir = REFERENCE_DIR / "vasp_example3"
        if not ref_dir.exists():
            pytest.skip("VASP reference data not generated")

        expected_files = [
            "rdf_lambda_f_f.npz",
            "number_density_f.npz",
        ]

        for filename in expected_files:
            ref_path = ref_dir / filename
            assert ref_path.exists(), f"Missing reference: {ref_path}"
            data = np.load(ref_path)
            assert len(data.files) > 0, f"Empty reference: {ref_path}"

    def test_synthetic_references_exist(self):
        """Synthetic reference files exist and are loadable."""
        ref_dir = REFERENCE_DIR / "synthetic"
        if not ref_dir.exists():
            pytest.skip("Synthetic reference data not generated")

        expected_files = [
            "uniform_gas_rdf.npz",
            "uniform_gas_density.npz",
        ]

        for filename in expected_files:
            ref_path = ref_dir / filename
            assert ref_path.exists(), f"Missing reference: {ref_path}"
            data = np.load(ref_path)
            assert len(data.files) > 0, f"Empty reference: {ref_path}"
